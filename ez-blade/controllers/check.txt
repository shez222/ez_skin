// -----------------------------------main----------------------------------------------
// const Jackpot = require('../models/jackpotSchema');
// const Item = require('../models/itemSchema');
// const User = require('../models/userSchema');
// const io = require('../socket');
// // const SteamTrade = require('steam-trade-api'); // Example Steam Trade API integration
// // const User = require('./models/User'); // Ensure correct import of your User model

// // Join the Jackpot
// const joinJackpot = async (req, res) => {
//   try {
//     const { userId, itemIds } = req.body;

//     // Validate user and items
//     if (!userId || !itemIds || itemIds.length === 0) {
//       return res.status(400).json({ error: 'User ID and item IDs are required' });
//     }

//     // Find or create the current jackpot (waiting or in-progress)
//     let jackpot = await Jackpot.findOne({ status: { $in: ['in_progress', 'waiting'] } });
//     if (!jackpot) {
//       jackpot = new Jackpot({ status: 'waiting', totalValue: 0, participants: [] });
//     }

//     // Fetch the user and items
//     const user = await User.findById(userId);
//     if (!user) return res.status(404).json({ error: 'User not found' });

//     const items = await Item.find({ _id: { $in: itemIds } });
//     if (items.length === 0) return res.status(404).json({ error: 'No items found' });

//     // Check if the user is already participating
//     const existingParticipant = jackpot.participants.find(participant => participant.user.equals(user._id));

//       // If user is not yet participating, add them with their items
//       jackpot.participants.push({
//         user: user._id,
//         items: items.map(item => item._id)
//       });

//     // Calculate the total value of the items added to the jackpot
//     const totalValue = items.reduce((acc, item) => {
//       const itemValue = parseFloat(item.value); // Convert item value to a float
//       if (!isNaN(itemValue)) {
//         return acc + itemValue;
//       }
//       return acc; // Skip invalid item values
//     }, 0);

//     jackpot.totalValue += totalValue;

//     // If there are 2 or more participants, move to 'in-progress'
//     if (jackpot.participants.length >= 2 && jackpot.status === 'waiting') {
//       jackpot.status = 'in_progress';
//     }

//     // Save the jackpot
//     const updatedJackpot = await jackpot.save();
//     io.getIO().emit('jackpots', {
//       action: 'update',
//       jackpot: updatedJackpot
//     })

//     res.json({ success: true, jackpot });
//   } catch (error) {
//     console.error('Error joining jackpot:', error);
//     res.status(500).json({ error: error.message });
//   }
// };


// // Get Jackpot Status
// const getJackpotStatus = async (req, res) => {
//   try {
//     // Find a jackpot that is either 'in_progress' or 'waiting'
//     let jackpot = await Jackpot.findOne({ status: { $in: ['in_progress', 'waiting'] } })
//       .populate('participants.user')  // Populate participant user details
//       .populate('participants.items') // Populate participant items
//       .populate('winner');            // Populate winner details if available

//     // If no jackpot is found, return a 404 error
//     if (!jackpot) {
//       return res.status(404).json({ error: 'No active jackpot found' });
//     }

//     // Respond with the jackpot data
//     res.json(jackpot);
//   } catch (error) {
//     console.error('Error fetching jackpot status:', error);
//     res.status(500).json({ error: error.message });
//   }
// };


// // Complete the Jackpot
// const completeJackpot = async (req, res) => {
//   try {
//     const { jackpotId } = req.body;

//     const jackpot = await Jackpot.findById(jackpotId)
//       .populate('participants.user')
//       .populate('participants.items');
      
    
//     if (!jackpot || jackpot.status !== 'in_progress') {
//       return res.status(404).json({ error: 'Jackpot not found or already completed' });
//     }

//     const totalValue = jackpot.totalValue;
//     let winner = null;

//     // Calculate odds for each participant based on the value of their items
//     const participantsWithOdds = jackpot.participants.map(participant => {
//       const participantValue = participant.items.reduce((acc, item) => acc + item.value, 0);
//       const odds = participantValue / totalValue;
//       return { participant: participant.user, odds };
//     });

//     // Select a winner based on calculated odds
//     const randomValue = Math.random();
//     let cumulativeOdds = 0;
//     for (const { participant, odds } of participantsWithOdds) {
//       cumulativeOdds += odds;
//       if (randomValue <= cumulativeOdds) {
//         winner = participant;
//         break;
//       }
//     }

//     if (winner) {
//       // Calculate commission and transfer items to the winner
//       const commissionValue = (jackpot.totalValue * jackpot.commissionPercentage) / 100;
//       const winnings = jackpot.totalValue - commissionValue;

//       // Implement trade logic here (e.g., using Steam API)
//       // await transferWinningsToWinner(winner, jackpot.items, winnings);

//       // Mark the jackpot as completed
//       jackpot.status = 'completed';
//       jackpot.winner = winner._id;
//       await jackpot.save();

//       return res.json({ success: true, jackpot });
//     }

//   } catch (error) {
//     console.error('Error completing jackpot:', error);
//     res.status(500).json({ error: error.message });
//   }
// };













  
// app.get('/api/inventory', async (req, res) => {
//   try {
//     const steamID64 = req.query.steamID64;
//     const appId = parseInt(req.query.appId, 10) || 252490;
//     const contextId = parseInt(req.query.contextId, 10) || 2;

//     if (!steamID64) {
//       return res.status(400).json({ error: 'Missing SteamID64 parameter.' });
//     }

//     const inventory = await getInventory(appId, steamID64, contextId);

//     // Find the user in the database
//     const user = await User.findOne({ steamId: steamID64 });
//     if (!user) {
//       return res.status(404).json({ error: 'User not found.' });
//     }

//     console.log("check 1");

//     // Save each item in the inventory to the database
//     const itemPromises = inventory.items.map(async (item, index) => {
//       try {
//         console.log(`Processing item ${index + 1} / ${inventory.items.length}: ${item.market_hash_name}`);

//         // Extract the numeric part from the price string and convert it to a number
//         const priceString = item.price; 
//         const priceMatch = priceString.match(/\d+(\.\d+)?/);
//         const price = priceMatch ? parseFloat(priceMatch[0]) : 0;

//         const newItem = new Item({
//           name: item.market_hash_name,
//           iconUrl: item.icon_url,
//           price: price,  // Save the numeric value
//           owner: user._id,
//           assetId: item.assetid,
//           appId: appId,
//           contextId: contextId,
//         });

//         const savedItem = await newItem.save();
//         console.log(`Item ${index + 1} saved: ${savedItem._id}`);
//         user.inventory.push(savedItem._id); // Add item reference to user's inventory
//         return savedItem;
//       } catch (itemError) {
//         console.error(`Error processing item ${index + 1}: ${item.market_hash_name}`, itemError);
//         throw itemError;
//       }
//     });

//     // Wait for all items to be saved
//     await Promise.all(itemPromises);
//     console.log("check 2");

//     // Save the updated user with inventory references
//     await user.save();
//     console.log('check 3');
//     console.log('inve', inventory.raw.descriptions[0]);
    
//     res.json(inventory);

//   } catch (error) {
//     console.error("Error in /api/inventory:", error);
//     res.status(500).json({ error: error.message });
//   }
// });










  // require('dotenv').config(); // Ensure this is at the top
// const express = require('express');
// const passport = require('passport');
// const SteamStrategy = require('passport-steam').Strategy;
// const session = require('express-session');
// const cors = require('cors');
// const axios = require('axios');
// const stripe = require('stripe')(process.env.STRIPE_API_SECRET_KEY); // Correctly initialize Stripe
// const fs = require('fs')
// const mongoose = require('mongoose')

// const app = express();
// const PORT = process.env.PORT || 5000;

// // Middleware
// app.use(express.json());
// app.use(cors({
//   origin:  'http://localhost:3000',
//   methods: ['GET', 'POST'],
//   credentials: true
// }));

// app.use(session({
//   secret: process.env.SESSION_SECRET || 'your_secret',
//   resave: false,
//   saveUninitialized: true,
//   cookie: { secure: false } // Set to true if using HTTPS
// }));

// app.use(passport.initialize());
// app.use(passport.session());

// // Configure Passport with Steam Strategy
// passport.serializeUser((user, done) => {
//   done(null, user);
// });

// passport.deserializeUser((obj, done) => {
//   done(null, obj);
// });

// passport.use(new SteamStrategy({
//     returnURL: 'http://localhost:5000/auth/steam/return',
//     realm: 'http://localhost:5000/',
//     apiKey: process.env.STEAM_API_KEY
//   },
//   (identifier, profile, done) => {
//     process.nextTick(() => {
//       profile.identifier = identifier;
//       return done(null, profile);
//     });
//   }
// ));

// // Function to get inventory
// const getInventory = async (appid, steamid, contextid = 2, tradeable = false) => {
//   if (typeof appid !== 'number') appid = 730;
//   if (typeof contextid === 'string') contextid = parseInt(contextid, 10);
//   if (typeof tradeable !== 'boolean') tradeable = false;
//   if (!steamid) {
//     throw new Error('SteamID is required');
//   }

//   try {
//     const response = await axios.get(`https://steamcommunity.com/inventory/${steamid}/${appid}/${contextid}`);
//     const body = response.data;

//     let items = body.descriptions;
//     let assets = body.assets;
//     let marketnames = [];
//     let assetids = [];
//     let prices = [];

//     // Load rust_market_items.json file
//     const rustMarketItems = await JSON.parse(fs.readFileSync('rust_market_items.json', 'utf-8'));

//     let data = {
//       raw: body,
//       items: items.map(item => {
//         // Find the corresponding price for the item from rust_market_items.json
//         const marketItem = rustMarketItems.find(marketItem => marketItem.name === item.market_hash_name);
//         const price = marketItem ? marketItem.price : 'Price not found';

//         return {
//           market_hash_name: item.market_hash_name,
//           icon_url: `https://steamcommunity-a.akamaihd.net/economy/image/${item.icon_url}`,
//           price: price
//         };
//       }),
//       marketnames: marketnames,
//       assets: assets,
//       assetids: assetids
//     };
//     console.log(data);
    
//     if (items) {
//       for (let i = 0; i < items.length; i++) {
//         marketnames.push(items[i].market_hash_name);
//         assetids.push(assets[i].assetid);
//         const marketItem = rustMarketItems.find(marketItem => marketItem.name === items[i].market_hash_name);
//         const price = marketItem ? marketItem.price : 'Price not found';
//         prices.push(price);
//       }
//     } else {
//       throw new Error('No items found in the inventory.');
//     }

//     if (tradeable) {
//       data.items = data.items.filter(x => x.tradable === 1);
//     }

//     return data;
//   } catch (error) {
//     console.error('Inventory Error:', error.response ? error.response.data : error.message);
//     throw error;
//   }
// };



// // Inventory Route
// app.get('/api/inventory', async (req, res) => {
//   try {
//     const steamID64 = req.query.steamID64;
//     const appId = parseInt(req.query.appId, 10) ||252490 ;
//     const contextId = parseInt(req.query.contextId, 10) || 2;
    
//     if (!steamID64) {
//       return res.status(400).json({ error: 'Missing SteamID64 parameter.' });
//     }

//     const inventory = await getInventory(appId, steamID64, contextId);
//     res.json(inventory);
//   } catch (error) {
//     res.status(500).json({ error: error.message });
//   }
// });

// // Create Payment Intent Route


// // // Routes
// // app.get('/', (req, res) => {
// //   res.send('API running');
// // });

// // Redirect to Steam login
// app.get('/auth/steam', passport.authenticate('steam'));

// // Steam authentication callback
// app.get('/auth/steam/return',
//   passport.authenticate('steam', { failureRedirect: '/' }),
//   (req, res) => {
//     const user = req.user;
//     const steamID64 = user.id;
//     const username = user.displayName;
//     const profile = user.profileUrl;
//     const avatar = {
//       small: user.photos[0].value,
//       medium: user.photos[1].value,
//       large: user.photos[2].value,
//     };

//     // Redirect to frontend with user info
//     const redirectUrl = `http://localhost:3000/?steamID64=${steamID64}&username=${username}&avatar=${JSON.stringify(avatar)}`;
//     res.redirect(redirectUrl);
//   }
// );

// // Route to redirect user to Steam Trade Offer URL page
// app.get('/trade-url', (req, res) => {
//   try {
//     const steamID64 = req.user?.id;
//     if (!steamID64) {
//       return res.status(401).json({ error: 'Unauthorized: No Steam ID found.' });
//     }
//     const tradeUrl = `https://steamcommunity.com/profiles/${steamID64}/tradeoffers/privacy#trade_offer_access_url`;
//     res.redirect(tradeUrl);
//   } catch (error) {
//     res.status(500).json({ error: error.message });
//   }
// });

// // Logout route
// app.get('/logout', (req, res) => {
//   req.logout(err => {
//     if (err) {
//       return next(err);
//     }
//     req.session.destroy(err => {
//       if (err) {
//         return next(err);
//       }
//       res.redirect('http://localhost:3000/'); // Redirect to your frontend after logout
//     });
//   });
// });

// // app.listen(PORT, () => {
// //   console.log(`Server is running on http://localhost:${PORT}`);
// // });
